// Code generated by MockGen. DO NOT EDIT.
// Source: default_ddd/app/internal/adapters/port (interfaces: CartItemPort,ProductPort,UserPort,OrderPort)

// Package mocks is a generated GoMock package.
package mocks

import (
	ddo "default_ddd/app/pkg/ddo"
	logger "default_ddd/app/pkg/logger"
	gomock "github.com/golang/mock/gomock"
	reflect "reflect"
)

// MockCartItemPort is a mock of CartItemPort interface
type MockCartItemPort struct {
	ctrl     *gomock.Controller
	recorder *MockCartItemPortMockRecorder
}

// MockCartItemPortMockRecorder is the mock recorder for MockCartItemPort
type MockCartItemPortMockRecorder struct {
	mock *MockCartItemPort
}

// NewMockCartItemPort creates a new mock instance
func NewMockCartItemPort(ctrl *gomock.Controller) *MockCartItemPort {
	mock := &MockCartItemPort{ctrl: ctrl}
	mock.recorder = &MockCartItemPortMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockCartItemPort) EXPECT() *MockCartItemPortMockRecorder {
	return m.recorder
}

// ChangeBatchStatusToCompleted mocks base method
func (m *MockCartItemPort) BatchChangeStatusToCompleted(arg0 logger.Logger) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BatchChangeStatusToCompleted", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// ChangeBatchStatusToCompleted indicates an expected call of ChangeBatchStatusToCompleted
func (mr *MockCartItemPortMockRecorder) ChangeBatchStatusToCompleted(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BatchChangeStatusToCompleted", reflect.TypeOf((*MockCartItemPort)(nil).BatchChangeStatusToCompleted), arg0)
}

// CreateCartItem mocks base method
func (m *MockCartItemPort) CreateCartItem(arg0 logger.Logger, arg1 *ddo.CartItemDDO, arg2 *ddo.ProductDDO) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateCartItem", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateCartItem indicates an expected call of CreateCartItem
func (mr *MockCartItemPortMockRecorder) CreateCartItem(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateCartItem", reflect.TypeOf((*MockCartItemPort)(nil).CreateCartItem), arg0, arg1, arg2)
}

// LoadCartItem mocks base method
func (m *MockCartItemPort) FillCartItem(arg0 *ddo.CartItemDDO) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "FillCartItem", arg0)
}

// LoadCartItem indicates an expected call of LoadCartItem
func (mr *MockCartItemPortMockRecorder) LoadCartItem(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FillCartItem", reflect.TypeOf((*MockCartItemPort)(nil).FillCartItem), arg0)
}

// LoadCartItems mocks base method
func (m *MockCartItemPort) FillCartItems(arg0 []ddo.CartItemDDO) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "FillCartItems", arg0)
}

// LoadCartItems indicates an expected call of LoadCartItems
func (mr *MockCartItemPortMockRecorder) LoadCartItems(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FillCartItems", reflect.TypeOf((*MockCartItemPort)(nil).FillCartItems), arg0)
}

// ReadCartItem mocks base method
func (m *MockCartItemPort) ReadCartItem() *ddo.CartItemDDO {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadCartItem")
	ret0, _ := ret[0].(*ddo.CartItemDDO)
	return ret0
}

// ReadCartItem indicates an expected call of ReadCartItem
func (mr *MockCartItemPortMockRecorder) ReadCartItem() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadCartItem", reflect.TypeOf((*MockCartItemPort)(nil).ReadCartItem))
}

// ReadCartItems mocks base method
func (m *MockCartItemPort) ReadCartItems() []ddo.CartItemDDO {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadCartItems")
	ret0, _ := ret[0].([]ddo.CartItemDDO)
	return ret0
}

// ReadCartItems indicates an expected call of ReadCartItems
func (mr *MockCartItemPortMockRecorder) ReadCartItems() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadCartItems", reflect.TypeOf((*MockCartItemPort)(nil).ReadCartItems))
}

// MockProductPort is a mock of ProductPort interface
type MockProductPort struct {
	ctrl     *gomock.Controller
	recorder *MockProductPortMockRecorder
}

// MockProductPortMockRecorder is the mock recorder for MockProductPort
type MockProductPortMockRecorder struct {
	mock *MockProductPort
}

// NewMockProductPort creates a new mock instance
func NewMockProductPort(ctrl *gomock.Controller) *MockProductPort {
	mock := &MockProductPort{ctrl: ctrl}
	mock.recorder = &MockProductPortMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockProductPort) EXPECT() *MockProductPortMockRecorder {
	return m.recorder
}

// CreateProduct mocks base method
func (m *MockProductPort) CreateProduct(arg0 *ddo.ProductDDO) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "CreateProduct", arg0)
}

// CreateProduct indicates an expected call of CreateProduct
func (mr *MockProductPortMockRecorder) CreateProduct(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateProduct", reflect.TypeOf((*MockProductPort)(nil).CreateProduct), arg0)
}

// ReadProduct mocks base method
func (m *MockProductPort) ReadProduct() *ddo.ProductDDO {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadProduct")
	ret0, _ := ret[0].(*ddo.ProductDDO)
	return ret0
}

// ReadProduct indicates an expected call of ReadProduct
func (mr *MockProductPortMockRecorder) ReadProduct() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadProduct", reflect.TypeOf((*MockProductPort)(nil).ReadProduct))
}

// MockUserPort is a mock of UserPort interface
type MockUserPort struct {
	ctrl     *gomock.Controller
	recorder *MockUserPortMockRecorder
}

// MockUserPortMockRecorder is the mock recorder for MockUserPort
type MockUserPortMockRecorder struct {
	mock *MockUserPort
}

// NewMockUserPort creates a new mock instance
func NewMockUserPort(ctrl *gomock.Controller) *MockUserPort {
	mock := &MockUserPort{ctrl: ctrl}
	mock.recorder = &MockUserPortMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockUserPort) EXPECT() *MockUserPortMockRecorder {
	return m.recorder
}

// CreateUser mocks base method
func (m *MockUserPort) CreateUser(arg0 *ddo.UserDDO) *ddo.UserDDO {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateUser", arg0)
	ret0, _ := ret[0].(*ddo.UserDDO)
	return ret0
}

// CreateUser indicates an expected call of CreateUser
func (mr *MockUserPortMockRecorder) CreateUser(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateUser", reflect.TypeOf((*MockUserPort)(nil).CreateUser), arg0)
}

// LoadUser mocks base method
func (m *MockUserPort) LoadUser(arg0 *ddo.UserDDO) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "LoadUser", arg0)
}

// LoadUser indicates an expected call of LoadUser
func (mr *MockUserPortMockRecorder) LoadUser(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LoadUser", reflect.TypeOf((*MockUserPort)(nil).LoadUser), arg0)
}

// ReadUser mocks base method
func (m *MockUserPort) FillUser() *ddo.UserDDO {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FillUser")
	ret0, _ := ret[0].(*ddo.UserDDO)
	return ret0
}

// ReadUser indicates an expected call of ReadUser
func (mr *MockUserPortMockRecorder) ReadUser() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FillUser", reflect.TypeOf((*MockUserPort)(nil).FillUser))
}

// MockOrderPort is a mock of OrderPort interface
type MockOrderPort struct {
	ctrl     *gomock.Controller
	recorder *MockOrderPortMockRecorder
}

// MockOrderPortMockRecorder is the mock recorder for MockOrderPort
type MockOrderPortMockRecorder struct {
	mock *MockOrderPort
}

// NewMockOrderPort creates a new mock instance
func NewMockOrderPort(ctrl *gomock.Controller) *MockOrderPort {
	mock := &MockOrderPort{ctrl: ctrl}
	mock.recorder = &MockOrderPortMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockOrderPort) EXPECT() *MockOrderPortMockRecorder {
	return m.recorder
}

// CreateOrder mocks base method
func (m *MockOrderPort) CreateOrder(arg0 logger.Logger, arg1 *ddo.OrderDDO) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateOrder", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateOrder indicates an expected call of CreateOrder
func (mr *MockOrderPortMockRecorder) CreateOrder(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateOrder", reflect.TypeOf((*MockOrderPort)(nil).CreateOrder), arg0, arg1)
}

// ReadOrder mocks base method
func (m *MockOrderPort) ReadOrder() *ddo.OrderDDO {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadOrder")
	ret0, _ := ret[0].(*ddo.OrderDDO)
	return ret0
}

// ReadOrder indicates an expected call of ReadOrder
func (mr *MockOrderPortMockRecorder) ReadOrder() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadOrder", reflect.TypeOf((*MockOrderPort)(nil).ReadOrder))
}
